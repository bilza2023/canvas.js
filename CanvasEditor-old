
export default class CanvasEditor {
    constructor(canvas) {
      this.canvas = canvas;  // Reference to TaleemCanvas
      this.selectedItem = null;
      this.handles = [];
      this.drag = false;
      this.activeHandle = null;
      this.lastMouseX = 0;
      this.lastMouseY = 0;
      this._onMouseMoveDirect = null; // <-- To hold our direct mousemove listener
  
      // Attach EventModule listeners for dblclick, mousedown, and mouseup.
      // We no longer attach a mousemove from the EventModule for dragging.
      this.canvas.onMouse("dblclick", this.handleDoubleClick.bind(this));
      this.canvas.onMouse("mousedown", this.handleMouseDown.bind(this));
      this.canvas.onMouse("mouseup", this.handleMouseUp.bind(this));
    }
  
    handleDoubleClick(event, item) {
      if (item) {
        if (this.selectedItem !== item) {
          this.clearSelection();
        }
        this.selectedItem = item;
        this.createHandles();
      } else {
        this.clearSelection();
      }
    }
  
    handleMouseDown(event, item) {
      if (!this.selectedItem) return;
  
      // Convert client coordinates to canvas-relative coordinates.
      const rect = this.canvas.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
  
      // Check if any handle is hit.
      for (let handle of this.handles) {
        if (handle.isHit(mouseX, mouseY)) {
          // Activate the handle and start dragging.
          this.activeHandle = handle;
          this.drag = true;
          this.lastMouseX = mouseX;
          this.lastMouseY = mouseY;
          handle.set("color", "black");
  
          // **NEW:** Attach a direct mousemove listener to bypass hit detection.
          this._onMouseMoveDirect = this.handleMouseMoveDirect.bind(this);
          this.canvas.canvas.addEventListener("mousemove", this._onMouseMoveDirect);
          return;
        }
      }
  
      if (!item || item !== this.selectedItem) {
        this.clearSelection();
      }
    }
  
    // **NEW:** Direct mousemove handler for dragging.
    handleMouseMoveDirect(event) {
      if (!this.drag || !this.activeHandle) return;
  
      // Convert client coordinates to canvas coordinates.
      const rect = this.canvas.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
  
      const dx = mouseX - this.lastMouseX;
      const dy = mouseY - this.lastMouseY;
  
      // Update selected item based on the active handle type.
      if (this.activeHandle.type === "move") {
        this.selectedItem.x += dx;
        this.selectedItem.y += dy;
      } else if (this.activeHandle.type === "width") {
        this.selectedItem.width = Math.max(10, this.selectedItem.width + dx);
      } else if (this.activeHandle.type === "height") {
        this.selectedItem.height = Math.max(10, this.selectedItem.height + dy);
      }
  
      // Update the last known mouse positions.
      this.lastMouseX = mouseX;
      this.lastMouseY = mouseY;
  
      // Recreate handles at the new positions.
      this.createHandles();
    }
  
    handleMouseUp(event) {
      // End the drag and clear the active handle.
      this.drag = false;
      if (this.activeHandle) {
        this.activeHandle.set("color", this.getHandleColor(this.activeHandle.type));
      }
      this.activeHandle = null;
  
      // **NEW:** Remove the direct mousemove listener.
      if (this._onMouseMoveDirect) {
        this.canvas.canvas.removeEventListener("mousemove", this._onMouseMoveDirect);
        this._onMouseMoveDirect = null;
      }
    }
  
    createHandles() {
      this.clearHandles();
      // Create handles based on the selected item's updated position.
      this.handles = [
        this.createHandle(this.selectedItem.x, this.selectedItem.y, "move", "yellow"),
        this.createHandle(this.selectedItem.x + this.selectedItem.width, this.selectedItem.y, "width", "blue"),
        this.createHandle(this.selectedItem.x + this.selectedItem.width, this.selectedItem.y + this.selectedItem.height, "height", "purple")
      ];
    }
  
    createHandle(x, y, type, color) {
      const handle = this.canvas.add.rectangle();
      handle.x = x - 7;
      handle.y = y - 7;
      handle.width = 15;
      handle.height = 15;
      handle.set("color", color);
      handle.type = type;
      return handle;
    }
  
    getHandleColor(type) {
      return type === "move" ? "yellow" : type === "width" ? "blue" : "purple";
    }
  
    clearHandles() {
      this.handles.forEach(handle => this.canvas.remove(handle));
      this.handles = [];
    }
  
    clearSelection() {
      this.clearHandles();
      this.selectedItem = null;
    }
  }
  